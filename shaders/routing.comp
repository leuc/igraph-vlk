#version 450

// We process 256 edges simultaneously per workgroup
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// 1. The input nodes (Position, Size, etc.)
struct Node {
    vec3 position;
    float pad1;
    vec3 color;
    float size;
    int degree;
    int pad2, pad3, pad4; // Padding for 16-byte alignment
};

layout(std430, binding = 0) readonly buffer NodeBuffer {
    Node nodes[];
};

// 2. The output Edge paths
// We allocate 6 vec4s for the path: (x, y, z, alpha_glow)
struct Edge {
    int sourceId;
    int targetId;
    int elevationLevel; // Determines how high off the sphere the trace floats
    int pathLength;     // Usually 6 for a full circuit route
    vec4 path[6];       // The control points
};

layout(std430, binding = 1) buffer EdgeBuffer {
    Edge edges[];
};

// Push constants for global layout parameters
layout(push_constant) uniform Constants {
    int maxEdges;
    float baseRadius;
} pc;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= pc.maxEdges) return;

    int srcId = edges[idx].sourceId;
    int dstId = edges[idx].targetId;
    int elevation = edges[idx].elevationLevel;

    vec3 srcPos = nodes[srcId].position;
    vec3 dstPos = nodes[dstId].position;

    // Radius of the source sphere
    float sphereRadius = length(srcPos); 
    if (sphereRadius < 0.001) sphereRadius = pc.baseRadius;
    
    // Calculate the elevated highway radius
    // E.g., level 0 is flat, level 1 floats 0.5 units above, etc.
    float highwayRadius = sphereRadius + (float(elevation) * 0.5) + 0.1;

    // Convert Cartesian to Spherical for routing
    // Source
    vec3 srcNorm = normalize(srcPos);
    float srcLat = acos(srcNorm.y); // Y is up
    float srcLon = atan(srcNorm.z, srcNorm.x);
    
    // Target
    vec3 dstNorm = normalize(dstPos);
    float dstLat = acos(dstNorm.y);
    float dstLon = atan(dstNorm.z, dstNorm.x);

    // --- Generate the 6 Control Points ---
    
    // Point 0: The Source Node (Surface level)
    edges[idx].path[0] = vec4(srcPos, 1.0);

    // Point 1: Ascend to Highway Elevation
    vec3 p1 = srcNorm * highwayRadius;
    edges[idx].path[1] = vec4(p1, 1.0);

    // Point 2: Route along Longitude (Match Target's Longitude, keep Source's Latitude)
    // We calculate a new normal vector with mixed spherical coordinates
    vec3 p2Norm = vec3(
        sin(srcLat) * cos(dstLon),
        cos(srcLat),
        sin(srcLat) * sin(dstLon)
    );
    vec3 p2 = normalize(p2Norm) * highwayRadius;
    edges[idx].path[2] = vec4(p2, 1.0);

    // Point 3: Route along Latitude (Match Target's Latitude)
    vec3 p3Norm = vec3(
        sin(dstLat) * cos(dstLon),
        cos(dstLat),
        sin(dstLat) * sin(dstLon)
    );
    vec3 p3 = normalize(p3Norm) * highwayRadius;
    edges[idx].path[3] = vec4(p3, 1.0);

    // Point 4: Arrive directly above Target Node
    edges[idx].path[4] = vec4(p3, 1.0); // Duplicate for smooth cornering later if needed

    // Point 5: Drop down to Target Node (Surface level)
    edges[idx].path[5] = vec4(dstPos, 1.0);

    edges[idx].pathLength = 6;
}